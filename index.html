import streamlit as st
import requests
import threading
import time

"""
cccpRaider (Python version)
-------------------------
A Streamlit-based tool that sends messages to a Discord channel using one or more user tokens at a configurable interval.

**Important:**
- Sending automated messages can violate Discord's Terms of Service and result in account bans. Use this script responsibly and only on servers where you have explicit permission.
- For educational purposes only.

Run the app:
    $ streamlit run symraider.py
"""

# ------------- Helper functions -------------

def send_message(token: str, channel_id: str, message: str, log_fn):
    """Send a single message using the Discord HTTP API."""
    headers = {
        "Authorization": token,
        "Content-Type": "application/json",
    }
    payload = {"content": message}
    try:
        response = requests.post(
            f"https://discord.com/api/v10/channels/{channel_id}/messages",
            headers=headers,
            json=payload,
            timeout=10,
        )
        if response.ok:
            msg_id = response.json().get("id")
            log_fn(f"[SUCCESS] Token: {token[:10]}...  ID: {msg_id}")
        else:
            log_fn(
                f"[ERROR] Token: {token[:10]}...  Status: {response.status_code}"
            )
    except Exception as e:
        log_fn(f"[ERROR] Token: {token[:10]}...  {e}")


def spam_loop(tokens, channel_id, message, interval_ms, stop_event, log_fn):
    """Background loop that keeps sending messages until stop_event is set."""
    while not stop_event.is_set():
        for token in tokens:
            if stop_event.is_set():
                break
            send_message(token, channel_id, message, log_fn)
        stop_event.wait(interval_ms / 1000.0)

# ------------- Streamlit UI -------------

def main():
    st.set_page_config(page_title="SymRaider (Python)", page_icon="🐍")
    st.title("cccpRaider ")

    # Input widgets
    token_count = st.slider("Use Tokens", min_value=1, max_value=10, value=1, step=1)

    # Preserve tokens across reruns
    if "tokens" not in st.session_state:
        st.session_state.tokens = ["" for _ in range(token_count)]
    if len(st.session_state.tokens) < token_count:
        st.session_state.tokens.extend(["" for _ in range(token_count - len(st.session_state.tokens))])

    tokens = []
    for i in range(token_count):
        token = st.text_input(
            f"Token {i + 1}",
            value=st.session_state.tokens[i],
            type="password",
        )
        tokens.append(token)
        st.session_state.tokens[i] = token

    channel_id = st.text_input("Channel ID")
    message = st.text_area("Message")
    interval_ms = st.number_input("Send Interval (ms)", min_value=100, step=100, value=1000)

    # Runtime state
    if "running" not in st.session_state:
        st.session_state.running = False
        st.session_state.logs = []
        st.session_state.stop_event = threading.Event()

    def log_fn(text):
        timestamp = time.strftime("%H:%M:%S")
        st.session_state.logs.append(f"{timestamp} {text}")
        # Keep last 500 lines
        if len(st.session_state.logs) > 500:
            st.session_state.logs = st.session_state.logs[-500:]

    col_run, col_stop = st.columns(2)

    with col_run:
        if not st.session_state.running and st.button("Run", type="primary"):
            if any(not t for t in tokens):
                st.error("全てのトークンを入力してください。")
            elif not channel_id:
                st.error("Channel IDを入力してください。")
            elif not message:
                st.error("メッセージを入力してください。")
            else:
                # Start background thread
                st.session_state.stop_event.clear()
                threading.Thread(
                    target=spam_loop,
                    args=(tokens, channel_id, message, interval_ms, st.session_state.stop_event, log_fn),
                    daemon=True,
                ).start()
                st.session_state.running = True
                log_fn("Started spamming…")

    with col_stop:
        if st.session_state.running and st.button("Stop"):
            st.session_state.stop_event.set()
            st.session_state.running = False
            log_fn("Stopped.")

    st.subheader("Logs")
    st.code("\n".join(st.session_state.logs), language="text")


if __name__ == "__main__":
    main()
